using Altinn.Correspondence.Application.Helpers;
using Altinn.Correspondence.Application.MalwareScanResult.Models;
using Altinn.Correspondence.Core.Models.Entities;
using Altinn.Correspondence.Core.Models.Enums;
using Altinn.Correspondence.Core.Repositories;
using Altinn.Correspondence.Core.Services;
using Altinn.Correspondence.Core.Services.Enums;
using Hangfire;
using Microsoft.Extensions.Logging;
using OneOf;
using System.Security.Claims;

namespace Altinn.Correspondence.Application;

public class MalwareScanResultHandler(
    IAltinnRegisterService altinnRegisterService,
    IAttachmentRepository attachmentRepository,
    IAttachmentStatusRepository attachmentStatusRepository,
    ICorrespondenceRepository correspondenceRepository,
    ICorrespondenceStatusRepository correspondenceStatusRepository,
    UserClaimsHelper userClaimsHelper,
    IBackgroundJobClient backgroundJobClient,
    HangfireScheduleHelper hangfireScheduleHelper,
    ILogger<MalwareScanResultHandler> logger) : IHandler<ScanResultData, Task>
{
    public async Task<OneOf<Task, Error>> Process(ScanResultData data, ClaimsPrincipal? user, CancellationToken cancellationToken)
    {
        logger.LogInformation("Processing malware scan result for blob URI {BlobUri}", data.BlobUri);
        string attachmentIdFromBlobUri = data.BlobUri.Split("/").Last() ?? Guid.Empty.ToString();
        Guid attachmentId;
        if (!Guid.TryParse(attachmentIdFromBlobUri, out attachmentId))
        {
            logger.LogError("Could not parse Guid from blob URI {BlobUri}", attachmentIdFromBlobUri);
            return AttachmentErrors.AttachmentNotFound;
        }
        logger.LogDebug("Retrieving attachment {AttachmentId} with status history", attachmentId);
        var attachment = await attachmentRepository.GetAttachmentById(attachmentId, true, cancellationToken);
        if (attachment is null)
        {
            logger.LogError("Could not find attachment with ID {AttachmentId}", attachmentId);
            return AttachmentErrors.AttachmentNotFound;
        }
        logger.LogDebug("Looking up party information for sender {Sender}", attachment.Sender);
        var party = await altinnRegisterService.LookUpPartyById(attachment.Sender, cancellationToken);
        if (party?.PartyUuid is not Guid partyUuid)
        {
            logger.LogError("Could not find party UUID for sender {Sender}", attachment.Sender);
            return AuthorizationErrors.CouldNotFindPartyUuid;
        }
        logger.LogDebug("Retrieved party UUID {PartyUuid} for sender {Sender}", partyUuid, attachment.Sender);
        if (data.ScanResultType.Equals("No threats found", StringComparison.InvariantCultureIgnoreCase))
        {
            logger.LogInformation("Processing clean scan result for attachment {AttachmentId}", attachmentId);
            return await TransactionWithRetriesPolicy.Execute<Task>(async (cancellationToken) =>
            {
                logger.LogDebug("Setting attachment {AttachmentId} status to Published", attachmentId);
                await attachmentStatusRepository.AddAttachmentStatus(new AttachmentStatusEntity()
                {
                    Attachment = attachment,
                    AttachmentId = attachmentId,
                    Status = AttachmentStatus.Published,
                    StatusChanged = DateTimeOffset.UtcNow,
                    StatusText = AttachmentStatus.Published.ToString(),
                    PartyUuid = partyUuid
                }, cancellationToken);
                logger.LogDebug("Enqueueing attachment published event for attachment {AttachmentId}", attachmentId);
                backgroundJobClient.Enqueue<IEventBus>((eventBus) => eventBus.Publish(
                    AltinnEventType.AttachmentPublished, 
                    attachment.ResourceId, 
                    attachmentIdFromBlobUri, 
                    "Attachment Published", 
                    attachment.Sender, 
                    CancellationToken.None));
                logger.LogInformation("Successfully processed clean scan result for attachment {AttachmentId} with filename {FileName}", 
                    attachmentId, 
                    attachment.FileName);
                logger.LogDebug("Scheduling correspondence status check for attachment {AttachmentId}", attachmentId);
                backgroundJobClient.Enqueue(() => CheckCorrespondenceStatusesAfterDeleteAndPublish(attachmentId, partyUuid, CancellationToken.None));
                return Task.CompletedTask;
            }, logger, cancellationToken);
        }
        else
        {
            logger.LogWarning("Processing malicious scan result for attachment {AttachmentId}: {ScanResultType}", 
                attachmentId, 
                data.ScanResultType);
            return await TransactionWithRetriesPolicy.Execute<Task>(async (cancellationToken) =>
            {
                logger.LogDebug("Setting attachment {AttachmentId} status to Failed", attachmentId);
                await attachmentStatusRepository.AddAttachmentStatus(new AttachmentStatusEntity()
                {
                    Attachment = attachment,
                    AttachmentId = attachmentId,
                    Status = AttachmentStatus.Failed,
                    StatusChanged = DateTimeOffset.UtcNow,
                    StatusText = $"Malware scan failed: {data.ScanResultType}: {data.ScanResultDetails}",
                    PartyUuid = partyUuid
                }, cancellationToken);
                logger.LogDebug("Enqueueing attachment upload failed event for attachment {AttachmentId}", attachmentId);
                backgroundJobClient.Enqueue<IEventBus>((eventBus) => eventBus.Publish(
                    AltinnEventType.AttachmentUploadFailed, 
                    attachment.ResourceId, 
                    attachmentIdFromBlobUri, 
                    "Malware scan", 
                    attachment.Sender, 
                    CancellationToken.None));
                logger.LogWarning("Malicious content detected in attachment {AttachmentId} with filename {FileName}: {ScanResultType} - {ScanResultDetails}", 
                    attachmentId, 
                    attachment.FileName,
                    data.ScanResultType,
                    data.ScanResultDetails);
                return Task.CompletedTask;
            }, logger, cancellationToken);
        }
    }

    public async Task CheckCorrespondenceStatusesAfterDeleteAndPublish(Guid attachmentId, Guid partyUuid, CancellationToken cancellationToken)
    {
        logger.LogInformation("Checking correspondence statuses for attachment {AttachmentId}", attachmentId);
        logger.LogDebug("Retrieving attachment {AttachmentId} with status history", attachmentId);
        var attachment = await attachmentRepository.GetAttachmentById(attachmentId, true, cancellationToken);
        if (attachment == null)
        {
            logger.LogError("Attachment {AttachmentId} not found during correspondence status check", attachmentId);
            throw new Exception($"Attachment {attachmentId} not found");
        }
        logger.LogDebug("Retrieving non-published correspondences for attachment {AttachmentId}", attachmentId);
        var correspondences = await correspondenceRepository.GetNonPublishedCorrespondencesByAttachmentId(attachment.Id, cancellationToken);
        if (correspondences.Count == 0)
        {
            logger.LogInformation("No non-published correspondences found for attachment {AttachmentId}", attachmentId);
            return;
        }
        logger.LogInformation("Found {Count} non-published correspondences for attachment {AttachmentId}", 
            correspondences.Count, 
            attachmentId);
        foreach (var correspondence in correspondences)
        {
            logger.LogInformation("Scheduling publish for correspondence {CorrespondenceId} after dialog creation", correspondence.Id);
            await hangfireScheduleHelper.SchedulePublishAfterDialogCreated(correspondence.Id, cancellationToken);
        }
        logger.LogInformation("Successfully scheduled publish for {Count} correspondences after attachment {AttachmentId} publication", 
            correspondences.Count, 
            attachmentId);
    }
}