using Altinn.Correspondence.Application.Helpers;
using Altinn.Correspondence.Application.MalwareScanResult.Models;
using Altinn.Correspondence.Core.Models.Entities;
using Altinn.Correspondence.Core.Models.Enums;
using Altinn.Correspondence.Core.Repositories;
using Altinn.Correspondence.Core.Services;
using Altinn.Correspondence.Core.Services.Enums;
using Hangfire;
using Microsoft.Extensions.Logging;
using OneOf;
using System.Security.Claims;

namespace Altinn.Correspondence.Application;

public class MalwareScanResultHandler(
    IAltinnRegisterService altinnRegisterService,
    IAttachmentRepository attachmentRepository,
    IAttachmentStatusRepository attachmentStatusRepository,
    ICorrespondenceRepository correspondenceRepository,
    ICorrespondenceStatusRepository correspondenceStatusRepository,
    UserClaimsHelper userClaimsHelper,
    IBackgroundJobClient backgroundJobClient,
    HangfireScheduleHelper hangfireScheduleHelper,
    ILogger<MalwareScanResultHandler> logger) : IHandler<ScanResultData, Task>
{
    // Unique job ID prefix for wait-for-attachments jobs
    private const string WaitForAttachmentsJobIdPrefix = "wait-attachments-";
    
    // Maximum time to wait for attachments to be published (in minutes)
    private const int MaxWaitTimeMinutes = 5;

    public async Task<OneOf<Task, Error>> Process(ScanResultData data, ClaimsPrincipal? user, CancellationToken cancellationToken)
    {
        string attachmentIdFromBlobUri = data.BlobUri.Split("/").Last() ?? Guid.Empty.ToString();
        Guid attachmentId;
        if (!Guid.TryParse(attachmentIdFromBlobUri, out attachmentId))
        {
            logger.LogError("Could not parse Guid from {attachmentIdFromBlobUri}", attachmentIdFromBlobUri);
            return AttachmentErrors.AttachmentNotFound;
        }
        var attachment = await attachmentRepository.GetAttachmentByUrl(data.BlobUri, cancellationToken);
        if (attachment is null)
        {
            logger.LogError("Could not parse Guid from {attachmentIdFromBlobUri}", attachmentIdFromBlobUri);
            return AttachmentErrors.AttachmentNotFound;
        }
        var party = await altinnRegisterService.LookUpPartyById(attachment.Sender, cancellationToken);
        if (party?.PartyUuid is not Guid partyUuid)
        {
            return AuthorizationErrors.CouldNotFindPartyUuid;
        }

        if (data.ScanResultType.Equals("No threats found", StringComparison.InvariantCultureIgnoreCase))
        {
            return await TransactionWithRetriesPolicy.Execute<Task>(async (cancellationToken) =>
            {
                await attachmentStatusRepository.AddAttachmentStatus(new AttachmentStatusEntity()
                {
                    Attachment = attachment,
                    AttachmentId = attachmentId,
                    Status = AttachmentStatus.Published,
                    StatusChanged = DateTimeOffset.UtcNow,
                    StatusText = AttachmentStatus.Published.ToString(),
                    PartyUuid = partyUuid
                }, cancellationToken);
                backgroundJobClient.Enqueue<IEventBus>((eventBus) => eventBus.Publish(AltinnEventType.AttachmentPublished, attachment.ResourceId, attachmentIdFromBlobUri, "Attachment Published", attachment.Sender, CancellationToken.None));
                logger.LogInformation("Non-malicious result for {fileTransferId} with result type {scanResultType}", attachmentId, data.ScanResultType);
                backgroundJobClient.Enqueue(() => CheckCorrespondenceStatusesAfterDeleteAndPublish(attachmentId, partyUuid, CancellationToken.None));
                return Task.CompletedTask;
            }, logger, cancellationToken);
        }
        else
        {
            return await TransactionWithRetriesPolicy.Execute<Task>(async (cancellationToken) =>
            {
                await attachmentStatusRepository.AddAttachmentStatus(new AttachmentStatusEntity()
                {
                    Attachment = attachment,
                    AttachmentId = attachmentId,
                    Status = AttachmentStatus.Failed,
                    StatusChanged = DateTimeOffset.UtcNow,
                    StatusText = $"Malware scan failed: {data.ScanResultType}: {data.ScanResultDetails}",
                    PartyUuid = partyUuid
                }, cancellationToken);
                backgroundJobClient.Enqueue<IEventBus>((eventBus) => eventBus.Publish(AltinnEventType.AttachmentUploadFailed, attachment.ResourceId, attachmentIdFromBlobUri, "Malware scan", attachment.Sender, CancellationToken.None));
                logger.LogWarning("Malicious result for {fileTransferId} with result type {scanResultType}", attachmentId, data.ScanResultType);
                return Task.CompletedTask;
            }, logger, cancellationToken);
        }
    }

    public async Task CheckCorrespondenceStatusesAfterDeleteAndPublish(Guid attachmentId, Guid partyUuid, CancellationToken cancellationToken)
    {
        var attachment = await attachmentRepository.GetAttachmentById(attachmentId, true, cancellationToken);
        if (attachment == null)
        {
            throw new Exception($"Attachment {attachmentId} not found");
        }

        var correspondences = await correspondenceRepository.GetNonPublishedCorrespondencesByAttachmentId(attachment.Id, cancellationToken);
        if (correspondences.Count == 0)
        {
            logger.LogInformation("No correspondences associated with that attachmentId was found");
            return;
        }

        foreach (var correspondence in correspondences)
        {
            DateTimeOffset startTime = DateTimeOffset.UtcNow;

            var jobId = $"{WaitForAttachmentsJobIdPrefix}{correspondence.Id}";

            RecurringJob.AddOrUpdate(
                jobId, 
                () => WaitForAllAttachmentsAndPublish(correspondence.Id, startTime, CancellationToken.None), 
                "*/1 * * * *",
                new RecurringJobOptions { TimeZone = TimeZoneInfo.Utc });

            RecurringJob.TriggerJob(jobId);
        }
    }

    /// <summary>
    /// Checks if all attachments are published and schedules publish if they are.
    /// If all attachments are published, it schedules publish of correspondence and removes the recurring job.
    /// </summary>
    public async Task WaitForAllAttachmentsAndPublish(Guid correspondenceId, DateTimeOffset startTime, CancellationToken cancellationToken)
    {
        string jobId = $"{WaitForAttachmentsJobIdPrefix}{correspondenceId}";
        
        TimeSpan waitTime = DateTimeOffset.UtcNow - startTime;
        if (waitTime.TotalMinutes > MaxWaitTimeMinutes)
        {
            logger.LogWarning("Timeout exceeded waiting for attachments for correspondence {correspondenceId}. Waited for {minutes} minutes which exceeds the {maxMinutes} minute limit", 
                correspondenceId, waitTime.TotalMinutes, MaxWaitTimeMinutes);
            
            RecurringJob.RemoveIfExists(jobId);
            return;
        }
        
        var correspondence = await correspondenceRepository.GetCorrespondenceById(correspondenceId, true, false, false, cancellationToken);
        if (correspondence == null)
        {
            logger.LogWarning("Correspondence {correspondenceId} not found when checking attachments, cancelling recurring job and publishing", correspondenceId);

            RecurringJob.RemoveIfExists(jobId);
            return;
        }

        if (await correspondenceRepository.AreAllAttachmentsPublished(correspondenceId, cancellationToken))
        {
            logger.LogInformation("All attachments are published for correspondence {correspondenceId}, scheduling publish", correspondenceId);
            await hangfireScheduleHelper.SchedulePublishAfterDialogCreated(correspondence, cancellationToken);

            RecurringJob.RemoveIfExists(jobId);
        }
        else
        {
            logger.LogInformation("Not all attachments are published for correspondence {correspondenceId}, will check again on next schedule", correspondenceId);
        }
    }
}